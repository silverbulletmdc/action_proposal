import pickle
import argparse
import numpy as np

from action_proposals.dataset import VideoRecord
from action_proposals.dataset.temporal_dataset import VideoRecordHandler
from action_proposals.dataset.activitynet_dataset import ActivityNetDataset
from action_proposals.utils import cover_args_by_yml


def generate_proposals(scores: np.ndarray, video_record: VideoRecord) -> np.ndarray:
    r"""

    :param scores: [3, L], start, action, end
    :return: [2, N], proposals
    """
    peak_thres = 0.5

    start_scores, action, end_scores = scores
    max_start = max(start_scores)
    max_end = max(end_scores)
    
    # Get start and end bins.
    start_bins = np.zeros_like(start_scores)
    start_bins[[0, -1]] = 1
    start_bins[1:-1] = np.logical_and(start_scores[1:-1] > start_scores[2:], start_scores[1:-1] > start_scores[:-2])
    start_bins = np.logical_and(start_bins, start_scores > (peak_thres * max_start))

    end_bins = np.zeros_like(end_scores)
    end_bins[[0, -1]] = 1
    end_bins[1:-1] = np.logical_and(end_scores[1:-1] > end_scores[2:], end_scores[1:-1] > end_scores[:-2])
    end_bins = np.logical_and(end_bins, end_scores > (peak_thres * max_end))

    # Get start and end indexes and their scores.
    xmin_list = np.nonzero(start_bins)
    xmin_score_list = start_scores[xmin_list]

    xmax_list = np.nonzero(end_bins)
    xmax_score_list = end_scores[xmax_list]



    return scores


class TemHandler(VideoRecordHandler):
    def __init__(self, tem_results_file: str, subset: str = "training"):
        r"""
        TEM feature handler.

        :param tem_results_file: result file path of TEM generated by tem_test.
        :param subset: "training", "validation"
        """
        self._tem_results_file = tem_results_file
        with open(tem_results_file, 'rb') as f:
            results = pickle.load(f)
        self.tem_scores = results[subset]

    def __call__(self, video_record: VideoRecord):
        return self.tem_scores[video_record.idx], video_record


def get_tem_dataset(tem_results_file: str, json_path: str, video_info_new_csv_path: str, subset: str):
    video_record_handler = TemHandler(tem_results_file, subset)
    return ActivityNetDataset(json_path=json_path, video_info_new_csv_path=video_info_new_csv_path,
                              video_record_handler=video_record_handler, subset=subset)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--yml_cfg_file", type=str, default="bsn_config.yml")
    cfg = parser.parse_args()
    cover_args_by_yml(cfg, cfg.yml_cfg_file)
    train_dataset = get_tem_dataset(cfg.tem_results_file, cfg.json_path, cfg.video_info_new_csv_path, "training")
    val_dataset = get_tem_dataset(cfg.tem_results_file, cfg.json_path, cfg.video_info_new_csv_path, "validation")

    for i, (scores, video_record) in enumerate(train_dataset):
        generate_proposals(scores, video_record)
        print(i)
        print(scores.shape)
        print(video_record.video_name)












if __name__ == '__main__':
    main()
